### 概要
行为型模式主要用于描述类和对象之间的职责分配。
它主要包括11种设计模式：职责链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式。
行为型又可以通过类与类之间的关系进行划分 :
1. 父类与子类:
   策略模式
   模版方法模式
2. 两个类之间:
   观察者模式
   迭代器模式
   责任链模式
   命令模式
3. 类的状态:
   备忘录模式
   状态模式
4. 通过中间类:
   访问者模式
   中介者模式
   解释器模式

其中解释器模式与访问者模式学习难度较大。

名称| 场景 | 优点 | 缺点| 核心思想 | 生活中例子  | 代码例子
---|--- |---|---|---|--- |---
职责链模式 | 系统中有一连串的处理者可能要对某个对象进行处理 | 降低耦合，发送者与接收者无须拥有对方明确信息 | 增加复杂性                                                   | 一个对象在主流程处理值钱可能被一堆类所处理，这些类组成链表 | 击鼓传花 | [责任链](https://github.com/luo1993hao/luo/tree/master/arithmetic/src/main/java/org/luo/arithmetic/designpattern/behavioral/chain)
命令模式 | 系统中需要抽象出等待执行的行为，比如撤销（Undo）操作和恢复（Redo）等操作,使其请求调用者和请求的接收者需要解耦 | 解耦，请求者与接收者实现完全解耦 | 设计模式老毛病，具体命令类增多，导致系统复杂 | 发送者与接受者之间引入了命令类，将命令封装成了对象。 | 将军，士兵，军令状 | [命令模式](https://github.com/luo1993hao/luo/tree/master/arithmetic/src/main/java/org/luo/arithmetic/designpattern/behavioral/command)
解释器模式| 系统中将一个需要解释执行的语言中的句子表示为一个抽象语法树 | 良好的扩展性 | 解释器模型采用递归调用方法，将会导致调试非常复杂、效率可能降低 | 实现特定语法解析 | 摩斯密码 | 无
中介者模式 | 系统中对象与对象之间存在大量的关联关系 | 降低了对象之间的耦合性，使得对象易于独立地被复用。 | 中介出问题，整个程序玩完，道理和卖房中介卷钱跑路一样 | 众多类相互引用的时候，使用一个中介类来降低耦合。 | 房东，租客，中介 | [中介者模式](https://github.com/luo1993hao/luo/tree/master/arithmetic/src/main/java/org/luo/arithmetic/designpattern/behavioral/mediator)
备忘录模式| 系统中需要保持某个对象的历史快照 | 提供了一种可以恢复状态的机制。 | 资源消耗，如果保存状态过多时，每一次保存都会消耗内存 | “后悔药”、”历史快照”. |草稿箱 | [备忘录模式](https://github.com/luo1993hao/luo/tree/master/arithmetic/src/main/java/org/luo/arithmetic/designpattern/behavioral/memento)
观察者模式| 系统中一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知 | 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则 | 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 | 观察者与被观察者之间建立一种触发机制 |闹铃 | [观察者模式](https://github.com/luo1993hao/luo/tree/master/arithmetic/src/main/java/org/luo/arithmetic/designpattern/behavioral/observer)
状态模式| 代码里面存在一个很长的if else列表，而这些分支都是因为不同状态且状态可枚举下执行的操作不一样时考虑使用此模式 | 结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来 | 不满足开闭原则。新增新的状态类需要修改状态转换的源码。 | 有限状态下不同行为。各个状态之间是有流转，依赖，关联。且状态自动变化 |淘宝订单 | [状态模式](https://github.com/luo1993hao/luo/tree/master/arithmetic/src/main/java/org/luo/arithmetic/designpattern/behavioral/command)
策略模式| 系统中一个类有多个子类，而区分它们的只是他们直接的行为。 | 算法可以自由切换 | 所有策略类都需要对外暴露 | 一个场景，多种选择。把选择权交给用户 |出行方式 | 无
模板方法模式| 系统中有多个子类共有的方法，且逻辑相同 | 提取公共代码，便于维护。流程固定 | 每一个不同的实现都需要一个子类来实现，导致类的个数增加 | 流程全部标准化，需要微调请覆盖 |古时候科举写的八股文 | 无
访问者模式| 系统中需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类 | *开闭原则*。 你可以引入在不同类对象上执行的新行为， 且无需对这些类做出修改。 | 每次在元素层次结构中添加或移除一个类时， 你都要更新所有的访问者。 | 将数据结构与数据操作分离 |KPI考核 | 无
迭代器模式| 系统中你新写了一个数据结构，并且需要对它进行遍历操作 | 职责分离 | 类个数增加 | 将集合类的存储与遍历职责分开 |无 | [迭代器模式](https://github.com/luo1993hao/luo/tree/master/arithmetic/src/main/java/org/luo/arithmetic/designpattern/behavioral/iterator)
### 模式之间的差异与联系
- 都是两个类之间的关系
- 命令模式是在发送者和请求者之间将命令给包装一下，建立单向连接。
- 观察者是在被观察者与一个或者多个观察者之间建立的动态连接。
- 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
- 外观模式和中介者的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。
- 可以使用迭代器模式来遍历组合模式树
- 可以同时使用访问者模式和迭代器来遍历复杂数据结构，
- 你可以在创建复杂组合模式树时使用生成器， 因为这可使其构造步骤以递归的方式运行。
- 你可以结合使用生成器和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。
### 学习建议
#### 必学
- 责任链模式
- 观察者模式
- 状态模式
- 策略模式
- 模板方法模式
- 迭代器模式
#### 选学
- 命令模式
- 解释器模式
- 中介者模式
- 备忘录模式
- 访问者模式