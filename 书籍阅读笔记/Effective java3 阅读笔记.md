### 类和接口
- 使类和成员的可访问性最小化
  - 公有类的实力域不能公有
  - 长度非0的数组总是可变的
- 使可变性最小化
- 复合优于继承
- 接口优于抽象类
  - 单继承
  - 接口是定义混合类型的理想选择（标志接口）
  - 接口允许构造非层次化的类型框架（eg:歌唱家，作曲家）
  - 包装类( wrapper class)模式， 接口使得安全地增强类的功能成为
可能 。 如果使用抽象类来定义类型，那么程序员除了使用继承的手段来
增加功能，再没有其 他的选 择了 。 
- 为后代设计接口
  - 缺省方法目的为了便于使用lamaba
  - 谨慎设计缺省方法
 - 接口只用于定义类型
    - 常量接口模式是对接口的不良使用
    - 数字常量可以加下划线增加可读性
- 类层次优于标签类
- 静态成员类优于非静态成员类
  - 静态成员类
    - 普通的类，碰巧被声明在内部
    - 公有的辅助类，与他的外部类一起使用才有意义
  - 非静态成员类
  - 定义adapter ，允许外部的类的实例被看作是一个另一个不相关类的实例（Map的keyset,entrySet)
    - 没有static,每个实例都隐含地与外围类的外围实例相关联
    - 如果声明成员类不需要访问外围实例，加上static，目的：如果省略，则每个实例都会将一个额外的指向外围对象的引用，gc困难。
  - 匿名类
  - 局部类
### 方法
- 检查参数的有效性
- 必要时进行保护性拷贝
  - 对于构造器的每个可变参数进行保护性拷贝是必要的
  - 保护性拷贝是检查参数有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是原始对象
- 慎用重载
  - 要调用哪个重载方法是在编译时作出决定的（很容易出现错误调用）
  - 永远不要导出2个具有相同参数数目的重载方法
  - 你始终可以可以给方法起不同的名称，而不使用重载机制
 ```
     public static void main(String[] args) {
        Set<Integer> set = new TreeSet<Integer>();
        List<Integer> list = new ArrayList<Integer>();
        for (int i = -3; i < 3; i++) {
             set.add(i);
             list.add(i);
        }
        for (int i = 0; i < 3; i++) {
            set.remove(i);
            list.remove(i);
        }
        System.out.println(set+"  "+list);
    }
    结果：[-3, -2, -1]  [-2, 0, 2]
    原因：set. remove(i)调用选择重载方法 remove(E)，这里的 E是 集合( Integer)的元素类型
    而list
    remove(i )调用选择重载方法 remove (index )，它从列表的指定位直上去除元素 
重载的坏处显而易见。
 ```
 
 - 慎用可变参数
   - 每次调用可变参数都会导致一次数组分配和初始化。性能低
   - 如果入参需要一个或者多个，而不是0个或者多个。使用可变参数，会运行时报错
   - 代码不美观
 - 返回零长度的数组或者集合，而不是null
 ### 范型
 - 不要使用原生态类型
 - 消除非受检的警告
 ### 通用编程
- 局部变量作用域最小化
  - 如果在循环之后不再需要循环的变量，for循环优于while循环
    - 减少局部变量作用域
    - 更简短，增加可读性
- for-each循环优先于传统的for循环
  - 以下情况除外：
    - 解析过滤
    - 转换
    - 并行遍历多个集合
- 了解和使用类库
  - guava
  - java.util
  - apache.common
- 如果要得到精确答案，避免使用float与double
  - 二进制浮点运算，尤其不适合货币运算
- 基本类型优先于装箱基本类型
  - 装箱有额外引用，有null
  - 对装箱类型运用==几乎总是错误的
   - 如果其他类型更合适，尽量避免使用String
 - 通过接口引用对象
   - 除开以下几种：
      - 类实现了接口并且提供了额外方法
      - 值类这种很少会有多个实现的类
   - 如果没有合适的接口，就用类层次结构中提供了必要功能最小的具体类来引用对象。
- 接口优先于反射
  - 损失编译时检查
  - 代码冗余
  - 性能损失
- 谨慎进行优化
  - 要努力编写好的程序而不是快的程序
- 遵循普遍的命名规则
