## 基础知识
#### 编程概念
  - 流处理
  - 行为参数化把代码传递给方法
    - 行为参数化可以帮你处理频繁变更的需求的一种软件开发模式
    - 让方法接受多种行为作为参数，并在内部使用，来完成不同的行为
    - 策略类->匿名类->lambada 不断精简
    - 总的来说2大好处
      - 应对不断变化的需求比以前java7方便太多
      - 代码精简太多太多
  - 操作值：一等公民，方法和类:二等公民
  - 默认方法
  - java从函数式编程中引入的2个核心思想：将方法和lambda作为一等值，以及在没有可变共享状态时，函数，方法可以有效的，安全地并行执行
 ### lambda
- 可以理解为简洁地表示可传递的匿名函数的一种方式
- java8以前做不了的事儿，lambada也做不了，他只是简洁的方式传递笨重的代码
- 表达式
   - 参数列表
   - 箭头
   - lambda主体，包含返回值，可以多行
   - {parameters} ->expression
   - {parameters}->{statements;}
 - 函数式接口：只定义一个抽象方法的接口
   - lambda允许直接内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式的实例
 - java8中的函数式接口（后半部分被称为函数描述符）
   - Predicate:T->boolean
   - Consumer:T->void
   - Function:T->R
   - Supplier:()->T（用于创建对象）
   - UnaryOperator:T->T
   - BinaryOperator:(T,T)->T
   - BiPerdicate<L,R>->boolean
   - BiConsumer:(T,U)->void
   - BiFuncation:(T,U)->R
 - Lambda引用的局部变量必须是final
 - 方法引用
   - 快捷写法，语法糖
### 函数式数据处理
- 声明式方式处理数据集合
  - 声明性
  - 可复合
  - 可并行
### 流相关
- 可以把java8的流看作花哨又懒惰的数据集迭代器。
- 流特点
  - 流水线
  - 内部迭代
     - 比起外部迭代(for-each)的好处
        - 透明并行处理，更优化的顺序--这就是java8引入流的原因
  - 按需生产（延迟创建的集合，需求驱动->实时制造）
  - 只能遍历一次
  - 终端操作才执行，不是流的值
  - 中间操作（sort,fliter,map）会内部优化，称为循环合并
- 流的使用
   - 流扁平化
     - flatMap()
   - 归约
     -  reduce()
### 用流收集数据
- 查找流的最大最小值
- 连接字符串
- collect于reduce的区别
  - 语义：collect要改变容器，从而累积要输出的值，reduce是把2个值结合在一起生成一个新值
  - 实际：reduce不能并行工作
- 广义的归约汇总
  - Collectors.reducing 具体用法查api
- 分组 groupingBy
- 分区 paratitioningBy
- 可以分组，分区，归约复合使用
- 可以自己实现Collector接口中定义的方法来开发你自己的收集器
### 并行数据处理
- 默认的线程数量就是你处理器数量
- 适当的数据结构往往比并行化算法更重要（装箱，拆箱）
- 使用注意事项
  - 留意装箱（java8提供原始流）
  - 有些操作本身并行流就比顺序流性能差
  - 考虑成本
  - 小数据量，别用并行流
  - 数据结构是否容易分解
  - 合并代价
- 原理是java7中的分支/合并框架
### 高效java8编程
#### 重构
- 匿名类->Lambda
- lambda->方法引用
- 所有迭代器这种数据处理模式转换为streamApi
- lambda优化设计模式
  - 策略模式
  - 模版方式模式
  - 观察者模式
  - 责任链模式
  - 工厂模式
- 尽量将复杂的lambda表达式抽象到普通方法中
- peek:流的每个元素恢复运行之前，插入执行一个动作
- 涉及到lambdab表达式的栈跟踪可能非常难理解
### 组合式异步编程
#### Future接口
局限性
- 将两个异步计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第 一个的结果。
-  等待Future集合中的所有任务都完成。
- 仅等待Future集合中最快结束的任务完成(有可能因为它们试图通过不同的方式计算同
一个值)，并返回它的结果。
-  通过编程方式完成一个Future任务的执行(即以手工设定异步操作结果的方式)。
-  应对Future的完成事件(即当Future的完成事件发生时会收到通知，并能使用Future
- 计算的结果进行下一步的操作，不只是简单地阻塞等待操作的结果)。
#### CompletableFuture
**CompletableFuture和Future的关系就跟Stream和Collection的关系一样**
- 对集合并行计算的2种方式
 - 并行流
   - 计算密集，没有io
 - completableDuture
   - 等到io
 #### 新的时间api
- localDate,localTime
- 机器的日期和时间格式：Instant
- TemporalAdjuster：复杂操作，比如，将日期调整到下个周日、下个工作日，或者是本月的最后一天
- 格式化：DateTimeFormatter
### 函数式的思考
- 副作用
  - 除了构造器内的初始化操作，对类中数据结构的任何修改，包括字段的赋值操作(一个 典型的例子是setter方法)。
  - 抛出一个异常。
  - 进行输入/输出操作，比如向一个文件写数据。
- 没有副作用又称为引用透明性
 - 声明式编程
   - 采用“要做什么”风格的编程通常被称为声明式编程
 - 被称为“函数式”的函数或方法都只能修改本地变量。除此之外，它引用的 对象都应该是不可修改的对象（隐藏/避免并发带来的副作用）
 - 函数或者方法不应该抛出任何异常
 - 函数无论在何处、何时调用，如果使用同样的输入总能持续地得到相同的结果， 就具备了函数式的特征。
- 高阶函数
  -  接受至少一个函数作为参数   -  返回的结果是一个函数
- 科里化
 - 是一种将具备2个参数(比如，x和y)的函数f转化为使用一个参数的函数g，并 且这个函数的返回值也是一个函数，它会作为新函数的一个参数。后者的返回值和初始函数的 返回值相同，即f(x,y) = (g(x))(y)。
