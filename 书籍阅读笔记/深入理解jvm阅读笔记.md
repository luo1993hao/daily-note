### 内存区域
#### 运行时区域
- 程序计数器
  - 唯一没有规定oom
  - 当前线程所执行的字节码的行号指示器，字节码解释器通过改变该值来选择下一条执行的指令，将字节码变为机器码运行。在java方法中，记录的是字节码指令地址
- 虚拟机栈
  - 描述的是java方法执行的内存模型，由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息
- 本地方法栈
  - 与虚拟机栈类似
- java堆
- 方法区
 - 类信息、常量、静态变量、即时编译器编译后的代码等数据
- 运行时常量
- 直接内存
#### 对象的访问定位
 - 句柄
   - 堆中会划分一块区域作为句柄池
 - 直接指针
 
 优劣势：使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销
#### 对象的创建过程
![](https://i.loli.net/2019/01/17/5c40649d5b653.png)
 #### 垃圾收集器
- 对象是否死亡
  - 引用计数（相互循环引用）
  - 可达性分析算法
  - finalize()
- 垃圾收集算法
  - 标记-清除算法（效率不高，产生不连续碎片）
  - 复制算法（使用一半，代价高）用来回收新生代
  - 分代收集算法
  ##### hotSpot算法 内存回收的方法论
 - GC停顿线程
 - 准确式gc,oopMap
 - 安全点进行gc,程序是否长时间运行为标准（方法调用、循环跳转、异常跳转）
 - 安全区域-引用关系不会发生变化
 ##### 垃圾收集器 内存回收的具体实现
- 不同年代使用不同、组合使用收集器
- serial收集器 暂停其他所有线程
- parNew收集器，Serial多线程版本
- Parallel Scavenge收集器 可控制吞吐量
- Serial Old收集器 老年代
- Parallel Old收集器
- G1收集器 不载区分新生代、老年代
##### 理解GC日志
#### 类加载机制
##### 生命周期
加载->验证->准备->解析->初始化->使用->卸载
-----
- 加载
  - 全限定名->此类的二进制字节流
  - 内存生成一个class对象，作为方法区入口
- 验证
  - 连接第一步，确保字节流符合虚拟机要求
  - 文件格式验证（魔术开头、版本号）
  - 元数据验证（是否有父类、继承了不允许被继承的类。**Java语言规范**）
  - 字节码验证
  - 符号引用验证（确保解析能正常执行）
- 准备
  - 类变量分配内存并设置初始化
- 解析
  - 常量池内的符号引用替换为直接引用    
- 初始化
  - 执行类构造器<clinit>（）方法的过程（该方法是编译器自动收集类中所有类变量赋值动作和静态语句块合并产生的）
 - 类加载器
   - 通过一个类的全限定名来获取描述此类的二进制字节流
- 双亲委派模型
- 破坏双亲委派模型
