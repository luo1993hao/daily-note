### 演进中的架构

#### 原始分布式时代
- 为了实现调用本地方法跟调用远程方法一样，需要解决远程的服务在哪里(服务发现)，有多少个(负载均衡)， 网络出现分区、超时或者服务出错了怎么办(熔断、隔离、降级)，方法的参数与返回结 果如何表示(序列化协议)，信息如何传输(传输协议)，服务权限如何管理(认证、授 权)，如何保证通信安全(网络安全层)，如何令调用不同机器的服务返回相同的结果 (分布式数据一致性)等一系列问题
- 教训：某个功能能够 进行分布式，并不意味着它就应该 进行分布式，强行追求透明的分布式操 作，只会自寻苦果
#### 单体系统时代
- 不是反派角色，更接近于""自给自足"
- 拆分方便，问题出现在拆分过后的隔离与自治的缺陷。譬如内存泄漏影响整个程序。不能单独部署
#### soa时代
- 面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模
  式。
- 三种架构模型
  - 烟囱式
  - 微内核式
  - 事件驱动
- 定义了微服务许多方便的抽象。比如服务的发现，发布，治理，通信等
- 缺点
  - 过于严格的规范定义带来过度的复杂性
#### 微服务时代
- 分布式系统的最终目标
  - 像调用本地接口那样调用远程接口
  - 开发者只用专注于业务开发
#### 后服务时代
- 从软件层面独力应对微服务架构问题，发展到软、硬一体，合力应对架构问题的时 代，此即为“后微服务时代”。
- Kubernetes是pod层面，无法应对500导致的雪崩，解决办法：服务网格的边车代理模式。可以接管应用所有对外通信
#### 无服务时代
- 如果说微服务架构是分布式系统这条路的极致，那无服务架构，也许就是“不分布 式”的云端系统这条路的起点。
- 后端设施(Backend)
  - 数据库、消息队列、日志、存储。运行在云中。""后端即服务（Baas）"
- 函数(Function)
  - 业务逻辑代码。"函数既服务""
- 适用
  - 不需要交互的离线大规模计算
  - 短链接，无状态，事件驱动
- 不适用
  - 业务逻辑复杂，依赖服务端的，需要长链接，相应速度要求高的
### 架构师视角
#### 远程服务调用
- 最初的观点：rpc当做是ipc的一种特例（系统间的调用尽量做到透明）
- 反对的声音：网络进行分布式计算的八宗罪
- ipc方式
  - 管道（无格式字节流）
  - 信号
  - 信号量（信息量少）
  - 消息队列（实时性差）
  - 共享内存
  - socket
- rpc协议的三个问题
  - 如何表达数据（序列化与反序列化）
  - 如何传递数据（传输协议，最常见的HTTP）
  - 如何确定方法（不同语言如何表达同一个方法：给程序的每个方法都规定一个唯一的编号（UUID），WSDL,JSON-WSP）
