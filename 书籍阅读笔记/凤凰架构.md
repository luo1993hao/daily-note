### 演进中的架构

#### 原始分布式时代
- 为了实现调用本地方法跟调用远程方法一样，需要解决远程的服务在哪里(服务发现)，有多少个(负载均衡)， 网络出现分区、超时或者服务出错了怎么办(熔断、隔离、降级)，方法的参数与返回结 果如何表示(序列化协议)，信息如何传输(传输协议)，服务权限如何管理(认证、授 权)，如何保证通信安全(网络安全层)，如何令调用不同机器的服务返回相同的结果 (分布式数据一致性)等一系列问题
- 教训：某个功能能够 进行分布式，并不意味着它就应该 进行分布式，强行追求透明的分布式操 作，只会自寻苦果
#### 单体系统时代
- 不是反派角色，更接近于""自给自足"
- 拆分方便，问题出现在拆分过后的隔离与自治的缺陷。譬如内存泄漏影响整个程序。不能单独部署
#### soa时代
- 面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模
  式。
- 三种架构模型
  - 烟囱式
  - 微内核式
  - 事件驱动
- 定义了微服务许多方便的抽象。比如服务的发现，发布，治理，通信等
- 缺点
  - 过于严格的规范定义带来过度的复杂性
#### 微服务时代
- 分布式系统的最终目标
  - 像调用本地接口那样调用远程接口
  - 开发者只用专注于业务开发
#### 后服务时代
- 从软件层面独力应对微服务架构问题，发展到软、硬一体，合力应对架构问题的时 代，此即为“后微服务时代”。
- Kubernetes是pod层面，无法应对500导致的雪崩，解决办法：服务网格的边车代理模式。可以接管应用所有对外通信
#### 无服务时代
- 如果说微服务架构是分布式系统这条路的极致，那无服务架构，也许就是“不分布 式”的云端系统这条路的起点。
- 后端设施(Backend)
  - 数据库、消息队列、日志、存储。运行在云中。""后端即服务（Baas）"
- 函数(Function)
  - 业务逻辑代码。"函数既服务""
- 适用
  - 不需要交互的离线大规模计算
  - 短链接，无状态，事件驱动
- 不适用
  - 业务逻辑复杂，依赖服务端的，需要长链接，相应速度要求高的
### 架构师视角
#### 远程服务调用
- 最初的观点：rpc当做是ipc的一种特例（系统间的调用尽量做到透明）
- 反对的声音：网络进行分布式计算的八宗罪
- ipc方式
  - 管道（无格式字节流）
  - 信号
  - 信号量（信息量少）
  - 消息队列（实时性差）
  - 共享内存
  - socket
- rpc协议的三个问题
  - 如何表达数据（序列化与反序列化）
  - 如何传递数据（传输协议，最常见的HTTP）
  - 如何确定方法（不同语言如何表达同一个方法：给程序的每个方法都规定一个唯一的编号（UUID），WSDL,JSON-WSP）
#### 事务处理
##### 本地事务
- 单个服务使用单个数据源
- acid中c目的，aid是手段
- 实现原子性和持久性
   - 最大困难是"写入磁盘""这个操作不是原子的
   - 崩溃后恢复
     - "commit logging":先将操作信息写入日志，后追加一条完成记录（commit record），记录磁盘->数据库在日志看到成功后，真正的去修改数据->修改完成后再在日志中加入一条结束记录
     - commit logging缺陷：所有对数据的真实修改都必须发生在事务提交以后，对db性能不利。解决办法：Write-Ahead Logging
     - Write-Ahead Logging
       - FORCE:事务提交后。要求变动数据立即改变称为FORCE，否则为NO-FORCE（大多数DB为NO-FORCE）
       - STEAL：事务提交前，允许变动数据提前写入则称为 STEAL，否则NO-STEAL  
       - 允许NO-FORCE:redoLog
       - 允许STEAL：undoLog
       - NO-FORCE+STEAL性能最高。复杂度也最高
- 实现隔离性
  - 加锁
##### 全局事务
- 限定为一种适用于单个服务使用多个数据源场景的事务解决方案
- 分布式事务一致性问题，XA是规范：其核心内容是定义了全局的事务管理器(Transaction Manager，用于协调全局事 务)和局部的资源管理器(Resource Manager，用于驱动本地事务)之间的通信接口
- 2PC：准备阶段是在redoLog记录全部内容，不写入最后一条commitLog，持有锁
- 3PC：
    - 2PC准备阶段性能问题:将准备阶段一分为二，减少风险。
    - 单点问题：协调者宕机，默认策略是提交事务而不是持续等待
    - 仍然存在一致性风险问题（协调者收到参与者可以提交消息后，自己提交，但此时网络断开）
##### 共享事务
- 多个服务共用同一个数据源
##### 分布式事务
- 在分布式环境中，“一致性”不得不成为通常被牺牲、被放弃的那一项属性
- 可靠事件队列
  - 重试机制：最大努力交付
  - 需保证幂等
  - 缺乏隔离性。（超卖）
- tcc事务
  - 业务入侵。业务处理过程 必须拆分为“预留业务资源”和“确认/释放消费资源”两个子过程
- saga
  - 如果try阶段无法实现（例如用户购买书，直接扫码支付。如果用户、商家的账号余额由银行管理的话，无法实现）
  - 把一个大事务分解为可以交错运行的一系列子事务集合
  - 正向恢复
  - 反向恢复
  - 但由于系统会崩溃，必须设计成数据库类似的日志机制，跟踪子事务进度
  - 恢复代码难编写，一般不会自己写代码，由中间件实现
- 数据补偿思路
  - AT
### 透明多级分流系统
#### 客户端缓存
- 强制缓存（基于时效性）
  - Expires
  - Cache-Control
- 协商缓存（基于变化检测的缓存机制）
#### 域名解析
- 递归解析
#### 传输链路
- 连接数优化
- 传输压缩
  - 静态预压缩->即时压缩
#### 负载均衡
- 真正大型系统的负载均衡过程往往是多级的。会从 DNS 解析开始，通过“域名” → “CNAME” → “负载调度 服务” → “就近的数据中心入口”的路径
- 两大职责
  - 网关内部：“将用户请求转发过去”（请求的转发和代理过程）
    - 四层负载均衡
      - 性能高（银行的自助排号机）
      - 多种均衡器工作模式的统称。维持着同一个 TCP 连接，而不是说它只工作在第四层。事实上，这些模 式主要都是工作在二层(数据链路层，改写 MAC 地址)和三层(网络层，改写 IP 地址) 上
      - 不能跨子网
      - 一条TCP通道
    - 七层负载均衡
      - 功能强（银行的大堂经理）
      - 修改IP地址（源，目标）。方式
        - 新增数据包（需拆包，IP隧道）
        - 修改目的，源地址。（NAT模式）
      - 进行代理，两条独立的TCP通道
      - 代理：哪一方能感知到。正向代理：客户端可知，反向代理：服务器可知。透明代理：双方都不可知
  - “选择谁来处理用户请求”（均衡策略算法）
    - 轮询
    - 权重轮询
    - 随机
    - 一致性哈希均衡
    - 相应速度均衡
    - 最少连接数均衡
#### 缓存
- 出发点：缓解 CPU 和 I/ O 资源在峰值流量下的压力，“顺带”而非“专门”地提升响应性能。
- 命中率与淘汰策略
  - fifo
  - lru
  - lfu
    - tinylfu:缓解 LFU 每次访问都要修改计数器所带来的性能负担。"滑动时间窗""
- 分布式缓存
  - 复制式缓存
  - 集中性缓存
- 缓存风险
  - 缓存穿透
    - 恶意攻击:布隆过滤器
    - 不能避免：一段时间内设置返回NULL的之
  - 缓存雪崩
    - 集群
    - 多级缓存
    - 生存时间随机
  - 缓存击穿
    - 同步加锁
    - 代码手动管理
  - 缓存污染
### 架构安全性
#### 认证
- 你是谁，你能干什么，你如何证明
- 三种主流的认证方式
  - 通信信道（ SSL/TLS）
  - 通信协议（HTTP）
  - 通信内容（Web 内容）
- HTTP认证
  - 401：要产生身份凭证
  - 403：具体如何产生凭证
- web认证
  - 表单认证
#### 授权
- RBAC
- OAuth2
  - 第三方应用的认证授权协议。例如：我通过QQ扫码登录有道云词典
    - 第三方应用（有道云词典）
    - 授权服务器（QQ）
    - 资源服务器（它与认证服 务可以是相同的服务器，也可以是不同的服务器。QQ）
    - 资源所有者（我）
  - 4种方案
    - 授权码模式（最严谨）
    - 隐式授权模式
    - 密码模式
    - 客户端模式
#### 凭证
- Cookie-Session
  - 服务端与客户端联动来完成的状态管理机制
  - 单体服务
- JWT
  - 令牌头（签名算法）
  - payload（用户信息）
  - 签名
  - 问题
    - 令牌难以主动失效
    - 只能携带有限信息
#### 保密
- 端的保密与链路的保密
- 客户端加密
  - HTTPS
  - 客户端做什么防御措施，最终都会 沦为“马其诺防线”。
- 加密
  - 慢哈希函数是指这个函数执行时间是可以调节的哈希函数，通常是以控制调用次数来实 现的，BCrypt 算法
#### 传输
- 摘要:在源信息不泄漏的前提下辨别其真伪。不可逆
- 根据加密与解密是否采用同一个密钥，现代密码学算法可分为对称加密算法和非对称加密 两大类型。非对称:公钥加密，私钥解密
#### 验证
- 验证最好放在bean中
### 分布式的基石
#### 分布式共识算法
- 共识算法： 让分布式系统内部暂时容忍存在不同的状 态，但最终能够保证大多数节点的状态达成一致。并且在外部看来始终表示出一致的结果
- 以同步为代表的数据复制方法，被称为状态转移
- 能够使用确定的操作，促使状态间产生确定的转移结果的计算模型，在计算机科学中被称为状态机。
- "Quorum""少数服从多数"原则，使得增加机器数量对系统整体的可用性变成是有益的。
- Paxos 算法
  - 节点分类
    - 提案节点：称为 Proposer，提出对某个值进行设置操作的节点，设置值这个行为就被 称之为提案(Proposal)
    - 决策节点
    - 记录节点
    - Basic Paxos
      - 流程
        - 前提：决策者不会接受ID小于n的prepare与accept
        - 准备(Prepare) （抢占锁）
          - 如果某个提案节点准备发起提案， 必须先向所有的决策节点广播一个许可申请(称为 Prepare 请求)。
          - 提案节点的 Prepare 请求中会附带一个全局唯一的数字 n 作为提案 ID
          - 如果首次设值，返回（n,null）.否则返回(acceptedProposalId,acceptedValue)
        - 批准(Accept)
          - 如果提案者接收到所有的都是空，将自己的值与选案id，构成（id,value）。再次广播给全部的决策者（称为accept请求）
          - 如果不是最大。必须无条件地从应答中找出提案 ID 最大的那个值并接受，构成 一个二元组“(id, maxAcceptValue)。再次广播给全部的决策者
          - 当提案节点收到了多数派决策节点的应答(称为 Accepted 应答)后，协商结束，共识决 议形成
        - 存在的问题：
          - 单个值进行协议，至少两次网络请求
          - 活锁（如果两个提案节点交替使用更大的提 案 ID 使得准备阶段成功，但是批准阶段失败的话，这个过程理论上可以无限持续下 去）
      - Multi Paxos 
        - 增加提案节点选"主""过程。定时轮询，如果发现没有主节点，使用Basic Paxos的准备、批准的两轮网络交互过程，进行选主
        - 只有主节点本身能发出提案（就不会再有其他节点与它竞争，相当于是处于无并发的环境 当中进行的有序操作）
        - 节点只有主，从
        - 票型从二元组(id, value)已经变成了三元组(id, i, value)（i为任期编号，单调递增）。原因：主节点陷入网络分 区后重新恢复，但另外一部分节点仍然有多数派，且已经完成了重新选主的情况，此时必 须以任期编号大的主节点为准
- Gossip协议（最终一致性）
  - 如果有某一项信息需要在整个网络中所有节点中传播，那从信息源开始，选择一个固定 的传播周期(譬如 1 秒)，随机选择它相连接的 k 个节点(称为 Fan-Out)来传播消 息。
  - 每一个节点收到消息后，如果这个消息是它之前没有收到过的，将在下一个周期内，选 择除了发送消息给它的那个节点外的其他相邻 k 个节点发送相同的消息，直到最终网络 中所有节点都收到了消息。
  - 缺点：节点不一致，无法预计多长时间，消息冗余
#### 从类库到服务