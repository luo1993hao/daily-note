### 演进中的架构

#### 原始分布式时代
- 为了实现调用本地方法跟调用远程方法一样，需要解决远程的服务在哪里(服务发现)，有多少个(负载均衡)， 网络出现分区、超时或者服务出错了怎么办(熔断、隔离、降级)，方法的参数与返回结 果如何表示(序列化协议)，信息如何传输(传输协议)，服务权限如何管理(认证、授 权)，如何保证通信安全(网络安全层)，如何令调用不同机器的服务返回相同的结果 (分布式数据一致性)等一系列问题
- 教训：某个功能能够 进行分布式，并不意味着它就应该 进行分布式，强行追求透明的分布式操 作，只会自寻苦果
#### 单体系统时代
- 不是反派角色，更接近于""自给自足"
- 拆分方便，问题出现在拆分过后的隔离与自治的缺陷。譬如内存泄漏影响整个程序。不能单独部署
#### soa时代
- 面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模
  式。
- 三种架构模型
  - 烟囱式
  - 微内核式
  - 事件驱动
- 定义了微服务许多方便的抽象。比如服务的发现，发布，治理，通信等
- 缺点
  - 过于严格的规范定义带来过度的复杂性
#### 微服务时代
- 分布式系统的最终目标
  - 像调用本地接口那样调用远程接口
  - 开发者只用专注于业务开发
#### 后服务时代
- 从软件层面独力应对微服务架构问题，发展到软、硬一体，合力应对架构问题的时 代，此即为“后微服务时代”。
- Kubernetes是pod层面，无法应对500导致的雪崩，解决办法：服务网格的边车代理模式。可以接管应用所有对外通信
#### 无服务时代
- 如果说微服务架构是分布式系统这条路的极致，那无服务架构，也许就是“不分布 式”的云端系统这条路的起点。
- 后端设施(Backend)
  - 数据库、消息队列、日志、存储。运行在云中。""后端即服务（Baas）"
- 函数(Function)
  - 业务逻辑代码。"函数既服务""
- 适用
  - 不需要交互的离线大规模计算
  - 短链接，无状态，事件驱动
- 不适用
  - 业务逻辑复杂，依赖服务端的，需要长链接，相应速度要求高的
### 架构师视角
#### 远程服务调用
- 最初的观点：rpc当做是ipc的一种特例（系统间的调用尽量做到透明）
- 反对的声音：网络进行分布式计算的八宗罪
- ipc方式
  - 管道（无格式字节流）
  - 信号
  - 信号量（信息量少）
  - 消息队列（实时性差）
  - 共享内存
  - socket
- rpc协议的三个问题
  - 如何表达数据（序列化与反序列化）
  - 如何传递数据（传输协议，最常见的HTTP）
  - 如何确定方法（不同语言如何表达同一个方法：给程序的每个方法都规定一个唯一的编号（UUID），WSDL,JSON-WSP）
#### 事务处理
##### 本地事务
- 单个服务使用单个数据源
- acid中c目的，aid是手段
- 实现原子性和持久性
   - 最大困难是"写入磁盘""这个操作不是原子的
   - 崩溃后恢复
     - "commit logging":先将操作信息写入日志，后追加一条完成记录（commit record），记录磁盘->数据库在日志看到成功后，真正的去修改数据->修改完成后再在日志中加入一条结束记录
     - commit logging缺陷：所有对数据的真实修改都必须发生在事务提交以后，对db性能不利。解决办法：Write-Ahead Logging
     - Write-Ahead Logging
       - FORCE:事务提交后。要求变动数据立即改变称为FORCE，否则为NO-FORCE（大多数DB为NO-FORCE）
       - STEAL：事务提交前，允许变动数据提前写入则称为 STEAL，否则NO-STEAL  
       - 允许NO-FORCE:redoLog
       - 允许STEAL：undoLog
       - NO-FORCE+STEAL性能最高。复杂度也最高
- 实现隔离性
  - 加锁
##### 全局事务
- 限定为一种适用于单个服务使用多个数据源场景的事务解决方案
- 分布式事务一致性问题，XA是规范：其核心内容是定义了全局的事务管理器(Transaction Manager，用于协调全局事 务)和局部的资源管理器(Resource Manager，用于驱动本地事务)之间的通信接口
- 2PC：准备阶段是在redoLog记录全部内容，不写入最后一条commitLog，持有锁
- 3PC：
    - 2PC准备阶段性能问题:将准备阶段一分为二，减少风险。
    - 单点问题：协调者宕机，默认策略是提交事务而不是持续等待
    - 仍然存在一致性风险问题（协调者收到参与者可以提交消息后，自己提交，但此时网络断开）
##### 共享事务
- 多个服务共用同一个数据源
##### 分布式事务
- 在分布式环境中，“一致性”不得不成为通常被牺牲、被放弃的那一项属性
- 可靠事件队列
  - 重试机制：最大努力交付
  - 需保证幂等
  - 缺乏隔离性。（超卖）
- tcc事务
  - 业务入侵。业务处理过程 必须拆分为“预留业务资源”和“确认/释放消费资源”两个子过程
- saga
  - 如果try阶段无法实现（例如用户购买书，直接扫码支付。如果用户、商家的账号余额由银行管理的话，无法实现）
  - 把一个大事务分解为可以交错运行的一系列子事务集合
  - 正向恢复
  - 反向恢复
  - 但由于系统会崩溃，必须设计成数据库类似的日志机制，跟踪子事务进度
  - 恢复代码难编写，一般不会自己写代码，由中间件实现
- 数据补偿思路
  - AT
### 透明多级分流系统
#### 客户端缓存
- 强制缓存（基于时效性）
  - Expires
  - Cache-Control
- 协商缓存（基于变化检测的缓存机制）
#### 域名解析
- 递归解析
#### 传输链路
- 连接数优化
- 传输压缩
  - 静态预压缩->即时压缩
#### 负载均衡
- 真正大型系统的负载均衡过程往往是多级的。会从 DNS 解析开始，通过“域名” → “CNAME” → “负载调度 服务” → “就近的数据中心入口”的路径
- 两大职责
  - 网关内部：“将用户请求转发过去”（请求的转发和代理过程）
    - 四层负载均衡
      - 性能高（银行的自助排号机）
      - 多种均衡器工作模式的统称。维持着同一个 TCP 连接，而不是说它只工作在第四层。事实上，这些模 式主要都是工作在二层(数据链路层，改写 MAC 地址)和三层(网络层，改写 IP 地址) 上
      - 不能跨子网
      - 一条TCP通道
    - 七层负载均衡
      - 功能强（银行的大堂经理）
      - 修改IP地址（源，目标）。方式
        - 新增数据包（需拆包，IP隧道）
        - 修改目的，源地址。（NAT模式）
      - 进行代理，两条独立的TCP通道
      - 代理：哪一方能感知到。正向代理：客户端可知，反向代理：服务器可知。透明代理：双方都不可知
  - “选择谁来处理用户请求”（均衡策略算法）
    - 轮询
    - 权重轮询
    - 随机
    - 一致性哈希均衡
    - 相应速度均衡
    - 最少连接数均衡
#### 缓存
- 出发点：缓解 CPU 和 I/ O 资源在峰值流量下的压力，“顺带”而非“专门”地提升响应性能。
- 命中率与淘汰策略
  - fifo
  - lru
  - lfu
    - tinylfu:缓解 LFU 每次访问都要修改计数器所带来的性能负担。"滑动时间窗""
- 分布式缓存
  - 复制式缓存
  - 集中性缓存
- 缓存风险
  - 缓存穿透
    - 恶意攻击:布隆过滤器
    - 不能避免：一段时间内设置返回NULL的之
  - 缓存雪崩
    - 集群
    - 多级缓存
    - 生存时间随机
  - 缓存击穿
    - 同步加锁
    - 代码手动管理
  - 缓存污染
### 架构安全性
#### 认证
- 你是谁，你能干什么，你如何证明
- 三种主流的认证方式
  - 通信信道（ SSL/TLS）
  - 通信协议（HTTP）
  - 通信内容（Web 内容）
- HTTP认证
  - 401：要产生身份凭证
  - 403：具体如何产生凭证
- web认证
  - 表单认证
#### 授权
- RBAC
- OAuth2
  - 第三方应用的认证授权协议。例如：我通过QQ扫码登录有道云词典
    - 第三方应用（有道云词典）
    - 授权服务器（QQ）
    - 资源服务器（它与认证服 务可以是相同的服务器，也可以是不同的服务器。QQ）
    - 资源所有者（我）
  - 4种方案
    - 授权码模式（最严谨）
      - 
    - 隐式授权模式
    - 密码模式
    - 客户端模式