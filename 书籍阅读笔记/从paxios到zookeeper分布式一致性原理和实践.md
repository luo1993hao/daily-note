 ### 分布式架构
 #### 分布式特点
 - 分布性
 - 对等性
 - 并发性
 - 缺乏全局时钟
 - 故障总会发生
 #### BASE理论
 - Basically Available(基本可用)
 - soft state(软状态)
 - eventually consistent（最终一致性）
 - 核心思想是即使无法做到强一致性，但每个应用可以根据自身的业务特点，采用适当的方式使系统达到最终一致性
### zookeeper
 #### 场景
绝大多数场景都是基于watcher监听机制与临时节点会话失效后自动清除。
- 数据发布/订阅
  - 配置中心
- 负载均衡
  - 动态dns
    - 域名注册
    - 域名解析
    - 域名探测（健康度检查）
- 命名服务
- 分布式协调/通知
  - 系统机器间的通信方式
    - 心跳
    - 工作进度汇报
    - 系统调度
- 集群管理
  - 集群监控
  - 集群控制
- master选举
  - 比起db 唯一键好处是如果master挂了可以快速动态选举下一个Master
- 分布式锁
  - 共享锁
    - 第一版本：
      - 读请求，创建ip-R-序号的节点。写请求，创建ip-w-序号的节点。（序号依次递增）
      - （1）所有节点注册变更的watcher监听
      - 确定自己顺序。对于读请求：如果没有比自己序号小的/比自己小的都是读请求。获取。如果比自己小的有写请求。进入等待
      - 对于写请求：如果自己不是最小。进入等待
      - 接收到watcher通知后。重复步骤1
    - 这样会出现""羊群效应"：如果同一时间多个节点对应的客户端事务完成，zk服务器会短时间发送大量通知。
    - 改进版本：核心思想判断自己是否是所有节点中最小的（并发编程中的缩小锁范围思想）
      - 不再注册所有节点的watcher监听
        - 读请求：比自己序号小的最后一个写请求节点注册watcher监听
        - 写请求：比自己序号小的最后一个请求节点注册watcher监听
  - 排他锁
- 分布式队列
  - fifo（跟共享锁改进版本思路一致。创建节点->如果不是最小节点->注册比自己序号小的最后一个节点的watcher监听->等待）
  - Barrier模型（并行计算）
    - 跟jdk中CyclicBarrier思想一致。设置一个count。每次注册节点后获取所有节点。个数=count。则释放监听。个数<count，注册所有节点监听。进入等待
#### 在其他项目的应用
##### hadoop
- 主要用于实现ha
  - 多个resourceManager。一个Active，负责集群所有资源的管理与分配。其余standBy.
    - 创建临时锁节点。成功得分为active。失败的为standBy。
    - 所有standBy的注册watcher监听。当主节点挂掉后。收到watcher事件通知
    - 通过Fencing机制避免"脑裂""（做法就是创建节点时候携带zk的acl信息。防止其他节点进行更新）
##### Hbase
- 主要用于分布式协调    
##### kafka
- broker管理
- topic注册
- 消费者注册
- 负载均衡
  - 生产者负载均衡（通过watcher通知让生产者动态的获取broker和topic情况）
  - 消费者负载均衡
### 技术内幕
#### 系统模型
- 数据模型
  - znode
  - 持久节点
  - 临时节点
  - verson字段用于乐观锁
  - watcher机制
    - 客户端注册
    - 服务端处理
    - 客户端回调
- ACL （scheme:id:permission）
  - 权限模式
    - ip
    - digest
    - word
    - super
  - 授权对象
  - 权限
    - CREATE
    - DELETE
    - READ
    - WRITE
    - ADMIN
#### 序列化与协议
- 序列化使用Jute    
- 通信协议
  - 基于tcp/ip。请求包含请求头与请求体。相应包含相应头和相应体
  - 不同的请求/相应类型。数据结构不一样
#### 客户端
- zk实例
- ClientWatcherManager
- HostProvider：客户端地址列表管理器
- clientCnxn
  - SendThread(I/O)
  - EventThread(event)
#### 会话
- sessionId:高8位确定所在机器，后56位使用时间戳进行随机
##### 会话的的创建过程
- 初始化阶段
  - 初始化上述组件
- 会话创建阶段
  - 启动SendThread，EventThread，创建tcp连接，构建请求，发送请求
- 相应处理阶段
  - 接受请求，处理response，查询Watcher,处理事件
#### 服务器启动
- 单机 
  - 配置文件解析
  - 初始化数据管理器 
    - FileTxnSnapLog 根据配置文件解析出的快照数据目录dataDir与事务日志目录dataLogDir创建
  - 初始化io管理器
  - 数据恢复
  - 对外服务
- 集群（比单机多的步骤）
  - 创建quorumPeer实例（zks实例托管者。检测服务器状态和发起leader选举） (quorum:过半机器数)
  - 创建内存数据库zkDatabase
  - 初始化quorumPeer
  - 初始化leader选举（服务器id+最新ZXID+当前epoch=>大多数情况下都会投自己一票，FastLeaderElection算法）
  - leader选举（简单来说，哪个机器的数据越新，越有可能成为leader(先看zxid，然后看服务器id)）
#### leader选举
##### 大概流程
  - 优先选自己
  - 每个服务器都接收来自各个服务器的投票
  - 处理投票
    -zxid->myid 票形：（sid,zxid）
  - 每个服务器统计投票
  - 改变状态
##### 时机
- 服务器初始化
- 运行期间无法和leader保持连接
##### 服务器状态
- LOOKING
- FOLLOWING
- LEADING
- OBSERVER
##### 其他知识
- tcp规则：只允许sid大的服务器主动和其他服务器建立连接
#### 服务器角色
- Leader
  - 事务请求的唯一调度和处理者，保证集群事务处理的顺序性
  - 集群内部各服务器的调度着
  - 使用责任链来处理每一个客户端请求（7个Processor，事务处理，日志记录，事务提交）
- Follower
  - 处理非事务请求，转发事务请求给Leader
  - 参与事务请求的投票
  - 参与Leader选举投票
  - 使用责任链来处理请求（少了事务处理的Processor）
- observer
   - 不参与投票的follower(事务请求与leader选举)