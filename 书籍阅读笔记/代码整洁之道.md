### 童子军军规
**让营地比你来时干净**
### 函数
- 短小
  - if,else,while，里面的代码块应该只有一行，并且应该是一个函数调用语句
- 每个函数里面的语句为一个抽象级
- switch
  - 多态
  - 埋藏在较低的抽象级里面
- 使用描述性的名称
  - 别害怕长名称
- 方法入参尽量少
- 无副作用
  - 不要有时序性耦合
- 分别指令与询问（eg:set与boolean）
- 使用异常替代返回错误码（减去调用者代码量）
  - 抽取try/catch
  - 错误处理就是一件事情
### 注释
 - 好注释
   - 法律信息
   - 提供信息的注释
   - 对意图的注释
   - 阐述，如果参数，或者返回值是某   个标准库的一部分
   - 警示
   - todo注释
   - 放大，放大某种看来不合理的地方的重要性，例如xxString.trim()这类代码
- 坏注释
  - 日志注释
  - 循规式注释（每个方法，每个类都去写冗余注释）
  - 废话注释
  - 能用函数，变量就别用注释
  - 非本地信息（描述离它最近的代码）
### 异常
- 使用不可控异常
  - 可控异常的代价就是违反开闭原则。因为对软件中较低层级的修改，都将波及较高层的签名
  - 讲第三方api打包，自定义类来补货第三方抛出的各种异常
  - 将异常行为封装到特例对象中
  - 别返回null以及传递null
### 对象和数据结构
![](https://i.loli.net/2019/05/05/5cced6c0af24d.png)


![](https://i.loli.net/2019/05/05/5cced77936d86.png)

- 过程式代码难以添加新数据结构，因为必须修改所有函数，面向对象代码难以添加新函数，因为必须修改所有类
### 测试
- 整洁的测试
   -可读性
      -构造->操作->校验
- 双重标准
  - 有些事大概永远不会在生产环境中做，通过关乎内存或者cpu，不过却永远不会与整洁有关
- 每个测试一个概念
- 5大准则
  - Fast
  - Independent
  - Repeatable
  - Self-Validating
  - Timely
### 类
- 自顶而下
- 短小
   - 不用if,and,or,but，能25个单词描述一个类
   - 只有一个修改的理由
   - 单一职责
   - 内聚
   - 依赖倒置原则
     - 类应该依赖于抽象，而不是依赖于细节
### 迭进（按照重要性排序）
- 运行所有测试
- 重构（基于所有测试）
  - 不可重复
  - 表达意图（命名，良好的测试）
  - 尽可能 减少类和方法的数量
### 并发
- 并发防御原则
  - 单一职责
  - 限制作用域
  - 使用数据副本
  - 线程尽可能独立
- 执行模型
 - 生产者，消费者
 - 读者-作者模型
 - 宴席哲学家
 

## 味道与启发
- 注释
  - 冗余注释
  - 废弃注释
  -注释掉的代码
- 函数
 - 过多的参数
- 一般性问题
  - 一个源文件多种语言（尽量减少）
  - 明显行为未被实现
  ![](https://i.loli.net/2019/05/06/5cd02ba341bdc.png)
  - 重复
  - 在错误的层级抽象代码
  ![](https://i.loli.net/2019/05/06/5cd02c17c3def.png)
  - 基类依赖于派生类
    - 基类应该对派生类一无所知
- 垂直分割
  ![](https://i.loli.net/2019/05/06/5cd02cb8a5310.png)
- 选择算子参数
![](https://i.loli.net/2019/05/06/5cd02f71c70fa.png)
  - 这里不是很明白。。大概能理解就是最好不要在方法中用true/false来分割2种完全不同的计算逻辑。这样会倒置调用者理解负担
- 错误位置的权责
  - 最小惊异原则(人为逻辑)
    - 哪里放代码？例如，PI常量应该哪儿？PI->三角函数
- 不恰当的静态方法
  - 通常选用非静态，如果的确需要静态，确保没机会打算让他多态
- 使用解释性变量
  - 让程序可读的最有力的方法就是将计算过程打散成有用的单词命名的变量
  ![](https://i.loli.net/2019/05/06/5cd0319bd0993.png)
- 函数名称应该表达其行为
  - 就一个原则：如果你必须查看函数的实现才知道他是做什么的，就应该换个函数名
- 把逻辑依赖改为物理依赖
 - A模块依赖于B,依赖者不应该对被依赖者模块有假定
 例如如上这个PAGE_SIZE,HR依赖于HRF能够应付55寸的页面，如果HRF某些实现不能处理，就会出错
  
![](https://i.loli.net/2019/05/06/5cd03c6148acb.png)
 - 用多态替代if/else,switch
   - 尽量吧。。这个实际情况中的确很难
 - 遵循团队约定
   - 只要全体同意在何处放置括号，那么在哪里放置都无关紧要
 - 命名常量替代魔数
   - 但如果有些常量具有自我解释能力，易于识别。就没必要使用变量来隐藏
 - 封装条件
 ![](https://i.loli.net/2019/05/06/5cd035b7613ad.png)
 - 避免否定条件
 ![](https://i.loli.net/2019/05/06/5cd035cc0f3c8.png)
 - 函数只做一个事情
 - 掩蔽时序耦合
 ![](https://i.loli.net/2019/05/06/5cd03719902cc.png)
 - 封装边界条件
  - 边界条件难以追踪，把处理边界条件放到一边，不想随意看到+1/-1的字样，并且可以提高可读性
- 函数应该只在一个抽象级（目前不是很懂）
- 在较高层放置可配置数据
- 避免传递浏览
![](https://i.loli.net/2019/05/06/5cd039ac1c358.png)
- 使用通配符避免过长的导入清单
- 不要继承常量
- 尽可能枚举替代常量
- 变量使用描述性名称
- 变量名/入参应该与抽象层级相符合
- 为较大作用范围选用较长名称
  - i,j这种命名对于作用范围5行之内没有问题
- 函数名应该能说明副作用