### 内存区域
#### 运行时区域
- 程序计数器
  - 唯一没有规定oom
- 虚拟机栈
- 本地方法栈
- java堆
- 方法区
- 运行时常量
- 直接内存
#### 的对象的访问定位
 - 句柄
 - 直接指针
 #### 垃圾收集器
- 对象是否死亡
  - 引用计数（相互循环引用）
  - 可达性分析算法
  - finalize()
- 垃圾收集算法
  - 标记-清除算法（效率不高，产生不连续碎片）
  - 复制算法（使用一半，代价高）用来回收新生代
  - 分代收集算法
  ##### hotSpot算法 内存回收的方法论
 - GC停顿线程
 - 准确式gc,oopMap
 - 安全点进行gc,程序是否长时间运行为标准（方法调用、循环跳转、异常跳转）
 - 安全区域-引用关系不会发生变化
 ##### 垃圾收集器 内存回收的具体实现
- 不同年代使用不同、组合使用收集器
- serial收集器 暂停其他所有线程
- parNew收集器，Serial多线程版本
- Parallel Scavenge收集器 可控制吞吐量
- Serial Old收集器 老年代
- Parallel Old收集器
- G1收集器 不载区分新生代、老年代
##### 理解GC日志
#### 类加载机制
##### 生命周期
加载->验证->准备->解析->初始化->使用->卸载
-----
- 加载
  - 全限定名->此类的二进制字节流
  - 内存生成一个class对象，作为方法区入口
- 验证
  - 连接第一步，确保字节流符合虚拟机要求
  - 文件格式验证（魔术开头、版本号）
  - 元数据验证（是否有父类、继承了不允许被继承的类。**Java语言规范**）
  - 字节码验证
  - 符号引用验证（确保解析能正常执行）
- 准备
  - 类变量分配内存并设置初始化
- 解析
  - 常量池内的符号引用替换为直接引用    
- 初始化
  - 执行类构造器<clinit>（）方法的过程（该方法是编译器自动收集类中所有类变量赋值动作和静态语句块合并产生的）
 - 类加载器
   - 通过一个类的全限定名来获取描述此类的二进制字节流
- 双亲委派模型
- 破坏双亲委派模型
