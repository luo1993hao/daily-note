### sql语言
- DQL:数据库查询语言
   - 由SELECT子句，FROM子句，WHERE
- DML:数据操纵语言
  - insert,update,delete
- DDL:数据定义语言
  - 用来创建数据库中的各种对象-----表、视图、
    索引、同义词、聚簇等如：
    CREATE TABLE/VIEW/INDEX/SYN/CLUSTER
- DCL:数据控制语言
   - 用来授予或回收访问数据库的某种特权，并控制
     数据库操纵事务发生的时间及效果，对数据库实行监视等。如：
     1) GRANT：授权。
     2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。
     回滚---ROLLBACK
     回滚命令使数据库状态回到上次最后提交的状态。其格式为：
     SQL>ROLLBACK;
     
     
     3) COMMIT [WORK]：提交
### mysql 优化几大原则
- 代码中sql语句优化
- 字段优化，索引优化
- 缓存
- 主从，读写分离
- 分区表
- 分表/分库    
### 锁
- 读锁：共享锁，s锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改
- 写锁：排他锁，x锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A
- 表锁：操作对象是数据表。Mysql大多数锁策略都支持(常见mysql innodb)，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。
  
- 行级锁：操作对象是数据表中的一行。是MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器。但行级锁对系统开销较大，处理高并发较好。
 ### mvcc
 - Multiversion Concurrency Control.多版本并发控制。不再单纯使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来。避免枷锁操作，减少开销。
 - 用于实现提交读和可重复读这两种隔离级别。未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现
 - 每个事务一个版本号。版本号=系统版本号。系统版本号递增。
 - InnoDb通过在每条记录后面加2个隐藏的列来实现，一个是创建时间的版本号，一个是删除的版本号。
 
   - insert:创建时间版本号=当前版本号
   - delete:删除时间版本号=当前版本号
   - update:可以理解为先删后增，2个独立的动作。
   - select：1.当前版本号>创建版本号&&当前版本号<删除版本号
 
 
 
 ### 几个原则
 - 尽量少使用select * 
   - 尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量 
  
Innodb存储引擎：


(1)     innodb存储引擎的物理结构包含 表空间、段、区、页、行 五个层级，数据文件按照主键排序存储在页中（页在逻辑上连续），主键的位置即为数据存储位置。

(2)     二级索引存储的数据为指定字段的值与主键值。当我们通过二级索引统计数据的时候，无需扫描数据文件；而通过主键索引统计数据时，由于主键索引与数据文件存放在一起，所以每次都会扫描数据文件，故大多数情况下，通过二级索引统计数据效率 >= 基于主键统计效率。

(3)    由于二级索引存储的数据为指定字段的值与主键值，故在无索引覆盖的情况下，查询二级索引后会根据二级索引获取的主键到主键索引中提取数据，此过程可能造成大量的随机io，导致查询速度较慢。

(4)    由于主键索引与数据存储保持一致，故基于主键的查找数据要比通过二级索引查询数据要快（使用二级索引时，查询到的数据条数>总条数的20%时候mysql就选择全表扫描，但在主键索引上，即使符合条件的达到 90%依然会走索引）。

### 预读
即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：
1. 当一个数据被用到时，其附近的数据也通常会马上被使用。
2. 　　程序运行期间所需要的数据通常比较集中。
3. 　　由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

 

