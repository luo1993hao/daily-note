### 锁
- 读锁：共享锁，s锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改
- 写锁：排他锁，x锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A
- 表锁：操作对象是数据表。Mysql大多数锁策略都支持(常见mysql innodb)，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。
  
- 行级锁：操作对象是数据表中的一行。是MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器。但行级锁对系统开销较大，处理高并发较好。
 ### mvcc
 Multiversion Concurrency Control.多版本并发控制。不再单纯使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来。
 
 
 ### 几个原则
 - 尽量少使用select * 
   - 尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量 
  
Innodb存储引擎：


(1)     innodb存储引擎的物理结构包含 表空间、段、区、页、行 五个层级，数据文件按照主键排序存储在页中（页在逻辑上连续），主键的位置即为数据存储位置。

(2)     二级索引存储的数据为指定字段的值与主键值。当我们通过二级索引统计数据的时候，无需扫描数据文件；而通过主键索引统计数据时，由于主键索引与数据文件存放在一起，所以每次都会扫描数据文件，故大多数情况下，通过二级索引统计数据效率 >= 基于主键统计效率。

(3)    由于二级索引存储的数据为指定字段的值与主键值，故在无索引覆盖的情况下，查询二级索引后会根据二级索引获取的主键到主键索引中提取数据，此过程可能造成大量的随机io，导致查询速度较慢。

(4)    由于主键索引与数据存储保持一致，故基于主键的查找数据要比通过二级索引查询数据要快（使用二级索引时，查询到的数据条数>总条数的20%时候mysql就选择全表扫描，但在主键索引上，即使符合条件的达到 90%依然会走索引）。

### 预读
即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：
1. 当一个数据被用到时，其附近的数据也通常会马上被使用。
2. 　　程序运行期间所需要的数据通常比较集中。
3. 　　由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

 

